use std::net::{IpAddr, Ipv6Addr};
use std::sync::Arc;

use camino::Utf8PathBuf;
use fsync::difftree::{DiffTree, TreeNode};
use fsync::ipc::Fsync;
use futures::future;
use futures::prelude::*;
use tarpc::{
    context::Context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Bincode,
};

#[derive(Debug, Clone)]
pub struct Service {
    tree: Arc<DiffTree>,
}

#[tarpc::server]
impl Fsync for Service {
    async fn entry(self, _: Context, path: Utf8PathBuf) -> Option<TreeNode> {
        self.tree.entry(&path)
    }
}

impl Service {
    pub fn new(tree: DiffTree) -> Self {
        Self {
            tree: Arc::new(tree),
        }
    }

    pub async fn start(&self) -> fsync::Result<()> {
        let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 0);

        let mut listener =
            tarpc::serde_transport::tcp::listen(&server_addr, Bincode::default).await?;

        println!("Listening on port {}", listener.local_addr().port());

        listener.config_mut().max_frame_length(usize::MAX);
        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated Fsync trait.
            .map(|channel| channel.execute(self.clone().serve()))
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;
        Ok(())
    }
}
